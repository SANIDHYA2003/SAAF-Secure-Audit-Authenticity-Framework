# VERIFYCHIAN - CODE TEMPLATES & BOILERPLATE
## Copy-Paste Ready Code for Quick Setup

---

## 1. SMART CONTRACT TEMPLATE (Solidity)

**File: `contracts/VerifyChain.sol`**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract VerifyChain is Ownable, ReentrancyGuard {
    
    // ==================== DATA STRUCTURES ====================
    
    struct Batch {
        string batchId;
        address manufacturer;
        string productName;
        uint256 quantity;
        uint256 createdAt;
        string status;
    }
    
    struct BlockRecord {
        uint256 blockNumber;
        string blockType;
        address actor;
        string location;
        uint256 temperature;
        string data;
        uint256 timestamp;
    }
    
    // ==================== STORAGE ====================
    
    mapping(string => Batch) public batches;
    mapping(string => BlockRecord[]) public blockHistory;
    mapping(address => bool) public authorizedUsers;
    
    string[] public allBatchIds;
    address[] public authorizedAddresses;
    
    // ==================== EVENTS ====================
    
    event BatchCreated(string indexed batchId, address indexed manufacturer, uint256 timestamp);
    event StatusChanged(string indexed batchId, string newStatus, uint256 timestamp);
    event BlockAdded(string indexed batchId, uint256 blockNumber, string blockType, uint256 timestamp);
    event AuthorizationChanged(address indexed user, bool status);
    
    // ==================== MODIFIERS ====================
    
    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender], "Not authorized");
        _;
    }
    
    // ==================== ADMIN FUNCTIONS ====================
    
    function authorizeUser(address _user) external onlyOwner {
        authorizedUsers[_user] = true;
        authorizedAddresses.push(_user);
        emit AuthorizationChanged(_user, true);
    }
    
    function revokeUser(address _user) external onlyOwner {
        authorizedUsers[_user] = false;
        emit AuthorizationChanged(_user, false);
    }
    
    // ==================== CORE FUNCTIONS ====================
    
    // CREATE BATCH (Manufacturer)
    function createBatch(
        string memory _batchId,
        string memory _productName,
        uint256 _quantity
    ) external onlyAuthorized {
        require(bytes(batches[_batchId].batchId).length == 0, "Batch exists");
        require(_quantity > 0, "Quantity must be > 0");
        
        batches[_batchId] = Batch({
            batchId: _batchId,
            manufacturer: msg.sender,
            productName: _productName,
            quantity: _quantity,
            createdAt: block.timestamp,
            status: "CREATED"
        });
        
        allBatchIds.push(_batchId);
        
        // Create Block #1
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: 1,
            blockType: "BatchCreated",
            actor: msg.sender,
            location: "",
            temperature: 0,
            data: _productName,
            timestamp: block.timestamp
        }));
        
        emit BatchCreated(_batchId, msg.sender, block.timestamp);
        emit BlockAdded(_batchId, 1, "BatchCreated", block.timestamp);
    }
    
    // TRANSFER BATCH (Manufacturer → Distributor)
    function transferBatch(
        string memory _batchId,
        address _to
    ) external onlyAuthorized {
        Batch storage batch = batches[_batchId];
        require(batch.manufacturer == msg.sender, "Only manufacturer can transfer");
        require(_to != address(0), "Invalid address");
        
        batch.status = "ASSIGNED";
        
        uint256 blockNum = blockHistory[_batchId].length + 1;
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: blockNum,
            blockType: "BatchTransferred",
            actor: msg.sender,
            location: "",
            temperature: 0,
            data: addressToString(_to),
            timestamp: block.timestamp
        }));
        
        emit StatusChanged(_batchId, "ASSIGNED", block.timestamp);
        emit BlockAdded(_batchId, blockNum, "BatchTransferred", block.timestamp);
    }
    
    // ACCEPT BATCH (Distributor)
    function acceptBatch(
        string memory _batchId,
        string memory _warehouseLocation,
        uint256 _temperature
    ) external onlyAuthorized {
        Batch storage batch = batches[_batchId];
        require(bytes(batch.batchId).length > 0, "Batch not found");
        batch.status = "AT_DISTRIBUTOR";
        
        uint256 blockNum = blockHistory[_batchId].length + 1;
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: blockNum,
            blockType: "DistributorAcceptedBatch",
            actor: msg.sender,
            location: _warehouseLocation,
            temperature: _temperature,
            data: "",
            timestamp: block.timestamp
        }));
        
        emit StatusChanged(_batchId, "AT_DISTRIBUTOR", block.timestamp);
        emit BlockAdded(_batchId, blockNum, "DistributorAcceptedBatch", block.timestamp);
    }
    
    // LOG TEMPERATURE (Transporter)
    function logTemperature(
        string memory _batchId,
        uint256 _temperature,
        string memory _location
    ) external onlyAuthorized {
        Batch storage batch = batches[_batchId];
        require(bytes(batch.batchId).length > 0, "Batch not found");
        
        uint256 blockNum = blockHistory[_batchId].length + 1;
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: blockNum,
            blockType: "TemperatureLogged",
            actor: msg.sender,
            location: _location,
            temperature: _temperature,
            data: "",
            timestamp: block.timestamp
        }));
        
        emit BlockAdded(_batchId, blockNum, "TemperatureLogged", block.timestamp);
    }
    
    // DELIVERY COMPLETED (Transporter)
    function completeDelivery(
        string memory _batchId,
        string memory _deliveryLocation
    ) external onlyAuthorized {
        Batch storage batch = batches[_batchId];
        batch.status = "DELIVERY_COMPLETED";
        
        uint256 blockNum = blockHistory[_batchId].length + 1;
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: blockNum,
            blockType: "TransportDeliveryCompleted",
            actor: msg.sender,
            location: _deliveryLocation,
            temperature: 0,
            data: "",
            timestamp: block.timestamp
        }));
        
        emit StatusChanged(_batchId, "DELIVERY_COMPLETED", block.timestamp);
        emit BlockAdded(_batchId, blockNum, "TransportDeliveryCompleted", block.timestamp);
    }
    
    // ACCEPT DELIVERY (Pharmacy) - OWNERSHIP TRANSFER
    function acceptDelivery(
        string memory _batchId,
        string memory _pharmacyLocation
    ) external onlyAuthorized {
        Batch storage batch = batches[_batchId];
        require(bytes(batch.batchId).length > 0, "Batch not found");
        batch.status = "AT_PHARMACY";
        
        uint256 blockNum = blockHistory[_batchId].length + 1;
        blockHistory[_batchId].push(BlockRecord({
            blockNumber: blockNum,
            blockType: "PharmacyAcceptedDelivery",
            actor: msg.sender,
            location: _pharmacyLocation,
            temperature: 0,
            data: "OWNERSHIP_TRANSFERRED",
            timestamp: block.timestamp
        }));
        
        emit StatusChanged(_batchId, "AT_PHARMACY", block.timestamp);
        emit BlockAdded(_batchId, blockNum, "PharmacyAcceptedDelivery", block.timestamp);
    }
    
    // ==================== READ FUNCTIONS ====================
    
    function getBatchDetails(string memory _batchId) 
        external 
        view 
        returns (Batch memory) 
    {
        return batches[_batchId];
    }
    
    function getBatchHistory(string memory _batchId) 
        external 
        view 
        returns (BlockRecord[] memory) 
    {
        return blockHistory[_batchId];
    }
    
    function getBlockCount(string memory _batchId) 
        external 
        view 
        returns (uint256) 
    {
        return blockHistory[_batchId].length;
    }
    
    function getAllBatches() 
        external 
        view 
        returns (string[] memory) 
    {
        return allBatchIds;
    }
    
    // ==================== UTILITY FUNCTIONS ====================
    
    function addressToString(address _addr) 
        internal 
        pure 
        returns (string memory) 
    {
        bytes32 _bytes = bytes32(uint256(uint160(_addr)));
        bytes memory HEX = "0123456789abcdef";
        bytes memory result = new bytes(42);
        result[0] = '0';
        result[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            result[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];
            result[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];
        }
        return string(result);
    }
}
```

---

## 2. BACKEND API TEMPLATE (Express.js)

**File: `backend/server.js`**

```javascript
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const { ethers } = require('ethers');
require('dotenv').config();

const app = express();

// ==================== MIDDLEWARE ====================

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ==================== DATABASE CONNECTION ====================

mongoose.connect(process.env.MONGODB_URL || 'mongodb://localhost:27017/verifychian')
    .then(() => console.log('✓ MongoDB connected'))
    .catch(err => console.log('✗ MongoDB error:', err));

// ==================== BLOCKCHAIN SETUP ====================

const provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
const contractAddress = process.env.CONTRACT_ADDRESS;
const contractABI = require('./abi/VerifyChain.json');

let contract;
if (contractAddress) {
    contract = new ethers.Contract(contractAddress, contractABI, provider);
}

// ==================== MODELS ====================

const userSchema = new mongoose.Schema({
    ethereumAddress: { type: String, unique: true, required: true },
    companyName: String,
    role: { type: String, enum: ['MANUFACTURER', 'DISTRIBUTOR', 'TRANSPORTER', 'PHARMACY', 'ADMIN'], required: true },
    email: String,
    permissions: [String],
    active: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now }
});

const User = mongoose.model('User', userSchema);

// ==================== AUTHENTICATION ROUTES ====================

app.post('/api/auth/login', async (req, res) => {
    try {
        const { ethereumAddress } = req.body;
        
        let user = await User.findOne({ ethereumAddress });
        
        if (!user) {
            user = new User({
                ethereumAddress,
                role: 'MANUFACTURER',
                active: true
            });
            await user.save();
        }
        
        // Generate JWT token
        const token = require('jsonwebtoken').sign(
            { address: ethereumAddress, role: user.role },
            process.env.JWT_SECRET || 'your-secret-key',
            { expiresIn: '7d' }
        );
        
        res.json({ success: true, token, user });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== BATCH ROUTES ====================

app.post('/api/batch/create', async (req, res) => {
    try {
        const { batchId, productName, quantity } = req.body;
        
        // Call smart contract (if signer available)
        // In production, use backend wallet to sign
        
        res.json({ 
            success: true, 
            batchId,
            message: 'Batch created successfully'
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/batch/:batchId', async (req, res) => {
    try {
        if (!contract) {
            return res.status(500).json({ error: 'Contract not initialized' });
        }
        
        const batch = await contract.getBatchDetails(req.params.batchId);
        const history = await contract.getBatchHistory(req.params.batchId);
        
        res.json({ batch, history });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== USER ROUTES ====================

app.get('/api/user/:address', async (req, res) => {
    try {
        const user = await User.findOne({ ethereumAddress: req.params.address });
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json(user);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/user/register', async (req, res) => {
    try {
        const { ethereumAddress, companyName, role, email } = req.body;
        
        const user = new User({
            ethereumAddress,
            companyName,
            role,
            email
        });
        
        await user.save();
        res.json({ success: true, user });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==================== HEALTH CHECK ====================

app.get('/api/health', (req, res) => {
    res.json({ status: 'OK', timestamp: new Date() });
});

// ==================== ERROR HANDLER ====================

app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});

// ==================== START SERVER ====================

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
    console.log(`✓ Server running on port ${PORT}`);
});
```

---

## 3. REACT FRONTEND TEMPLATE

**File: `frontend/src/pages/ManufacturerDashboard.jsx`**

```javascript
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { ethers } from 'ethers';

function ManufacturerDashboard() {
  const [batches, setBatches] = useState([]);
  const [loading, setLoading] = useState(false);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [formData, setFormData] = useState({
    productName: '',
    quantity: 0,
    expiryDate: ''
  });

  useEffect(() => {
    loadBatches();
  }, []);

  const loadBatches = async () => {
    try {
      setLoading(true);
      const response = await axios.get('/api/manufacturer/batches', {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      setBatches(response.data);
    } catch (error) {
      console.error('Error loading batches:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateBatch = async (e) => {
    e.preventDefault();
    try {
      setLoading(true);
      
      const { ethereum } = window;
      const provider = new ethers.BrowserProvider(ethereum);
      const signer = provider.getSigner();
      
      const response = await axios.post('/api/batch/create', formData, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });

      alert('✓ Batch created successfully!');
      setShowCreateForm(false);
      setFormData({ productName: '', quantity: 0, expiryDate: '' });
      loadBatches();
    } catch (error) {
      alert('✗ Error creating batch: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="manufacturer-dashboard">
      <h1>Manufacturer Dashboard</h1>
      
      {/* KPI Cards */}
      <div className="kpi-container">
        <div className="kpi-card">
          <h3>145</h3>
          <p>Batches Created</p>
        </div>
        <div className="kpi-card">
          <h3>2.5M</h3>
          <p>Units Produced</p>
        </div>
        <div className="kpi-card">
          <h3>₹2.15 Cr</h3>
          <p>Revenue</p>
        </div>
      </div>

      {/* Create Batch Button */}
      <button 
        onClick={() => setShowCreateForm(!showCreateForm)}
        className="btn btn-primary"
      >
        + Create Batch
      </button>

      {/* Create Batch Form */}
      {showCreateForm && (
        <div className="modal">
          <form onSubmit={handleCreateBatch}>
            <input
              type="text"
              placeholder="Product Name"
              value={formData.productName}
              onChange={(e) => setFormData({...formData, productName: e.target.value})}
              required
            />
            <input
              type="number"
              placeholder="Quantity"
              value={formData.quantity}
              onChange={(e) => setFormData({...formData, quantity: parseInt(e.target.value)})}
              required
            />
            <input
              type="date"
              placeholder="Expiry Date"
              value={formData.expiryDate}
              onChange={(e) => setFormData({...formData, expiryDate: e.target.value})}
              required
            />
            <button type="submit" disabled={loading}>
              {loading ? 'Creating...' : 'Create Batch'}
            </button>
          </form>
        </div>
      )}

      {/* Batches Table */}
      <div className="batches-table">
        <h2>Recent Batches</h2>
        {loading ? (
          <p>Loading...</p>
        ) : (
          <table>
            <thead>
              <tr>
                <th>Batch ID</th>
                <th>Product</th>
                <th>Quantity</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {batches.map(batch => (
                <tr key={batch._id}>
                  <td>{batch.batchId}</td>
                  <td>{batch.productName}</td>
                  <td>{batch.quantity}</td>
                  <td>{batch.status}</td>
                  <td>
                    <button onClick={() => console.log('View:', batch._id)}>View</button>
                    <button onClick={() => console.log('Track:', batch._id)}>Track</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
}

export default ManufacturerDashboard;
```

---

## 4. ENVIRONMENT VARIABLES TEMPLATES

**File: `smart-contracts/.env`**

```
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID
PRIVATE_KEY=YOUR_METAMASK_PRIVATE_KEY
ETHERSCAN_API_KEY=YOUR_ETHERSCAN_API_KEY
```

**File: `backend/.env`**

```
MONGODB_URL=mongodb+srv://username:password@cluster.mongodb.net/verifychian
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID
CONTRACT_ADDRESS=0x...deployed_contract_address
JWT_SECRET=your_jwt_secret_key
PORT=5000
```

**File: `frontend/.env`**

```
REACT_APP_API_URL=http://localhost:5000/api
REACT_APP_CONTRACT_ADDRESS=0x...deployed_contract_address
REACT_APP_NETWORK=sepolia
```

---

## 5. PACKAGE.JSON TEMPLATES

**File: `backend/package.json`**

```json
{
  "name": "verifychian-backend",
  "version": "1.0.0",
  "description": "VerifyChain Backend API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.0",
    "ethers": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "jsonwebtoken": "^9.0.0",
    "axios": "^1.3.0",
    "multer": "^1.4.5-lts.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.20"
  }
}
```

**File: `frontend/package.json`**

```json
{
  "name": "verifychian-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.3.0",
    "ethers": "^6.0.0",
    "web3modal": "^1.9.6",
    "react-router-dom": "^6.8.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version"]
  }
}
```

---

## 6. HARDHAT DEPLOYMENT SCRIPT

**File: `smart-contracts/scripts/deploy.js`**

```javascript
const hre = require("hardhat");

async function main() {
  console.log("Deploying VerifyChain contract...");

  const VerifyChain = await hre.ethers.getContractFactory("VerifyChain");
  const contract = await VerifyChain.deploy();

  await contract.deploymentTransaction().wait();

  console.log("✓ VerifyChain deployed to:", contract.target);
  console.log("\nAdd this to your .env file:");
  console.log(`CONTRACT_ADDRESS=${contract.target}`);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

---

## 7. HARDHAT CONFIG

**File: `smart-contracts/hardhat.config.js`**

```javascript
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
  solidity: "0.8.0",
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY],
      chainId: 11155111
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};
```

---

All code templates are ready to use. Copy-paste and modify as needed!
